import { FortuneManager, CardRecord, DailyCardState } from '../common/FortuneManager';
import { fileIo as fs, fileUri } from '@kit.CoreFileKit';
import { uniformTypeDescriptor as utd } from '@kit.ArkData';
import { TarotCard, TAROT_DECK, resolveDeckImage } from '../model/TarotData';
import common from '@ohos.app.ability.common';
import { abilityAccessCtrl } from '@kit.AbilityKit';
import { promptAction, curves, router, componentSnapshot } from '@kit.ArkUI';
import { formBindingData, formProvider } from '@kit.FormKit';
import { BottomNavBar } from '../common/BottomNavBar';
import { ImageSaver } from '../common/ImageSaver';
import { DeckSelectionSheet } from '../common/DeckSelectionSheet';
import { EnergyManager } from '../common/EnergyManager';
import { ShareHelper } from '../common/ShareHelper';
import { CloudService } from '../common/CloudService';
import { UserManager, UserInfo } from '../common/UserManager';
import { BusinessError } from '@kit.BasicServicesKit';
import { AIService } from '../common/AIService';

// 1. å®šä¹‰äº‘ç«¯èµ„æºå¸¸é‡
const OBS_PATH = 'https://taluopai.obs.cn-southwest-2.myhuaweicloud.com/tarot_cards/';
const CARD_BACK_URL = `${OBS_PATH}card_back.png`;
const QR_CODE_URL = `${OBS_PATH}qr_code.png`;

// ğŸŒŸ ç¨€æœ‰åº¦é…ç½®æ¥å£
interface RarityItem {
  level: number;
  label: string;
  color: string;
  desc: string;
}

// ğŸŒŸ ç¨€æœ‰åº¦é…ç½®
const RARITY_CONFIG: RarityItem[] = [
  { level: 1, label: 'N', color: 'rgba(200, 200, 200, 0.5)', desc: 'æ™®é€š' },
  { level: 3, label: 'R', color: 'rgba(60, 179, 113, 0.6)', desc: 'ç¨€æœ‰' },
  { level: 4, label: 'SR', color: 'rgba(30, 144, 255, 0.7)', desc: 'å²è¯—' },
  { level: 5, label: 'SSR', color: 'rgba(255, 69, 0, 0.8)', desc: 'ä¼ è¯´' },
  { level: 6, label: 'UR', color: 'rgba(255, 215, 0, 0.9)', desc: 'ç¥è¯' }
];

@Entry
@Component
struct Index {
  // === æ ¸å¿ƒæ•°æ® ===
  @State drawnCards: TarotCard[] = []; // å·²æŠ½å–çš„ç‰Œ
  @State drawnRarityLevels: number[] = [];
  @State drawnRarityColors: string[] = [];
  @State currentCard: TarotCard | null = null; // å½“å‰æ­£åœ¨åŠ¨ç”»/æ˜¾ç¤ºçš„ç‰Œ
  @State isFlipped: boolean = false;
  @State showResultText: boolean = false;
  @State isVip: boolean = false;

  // === ğŸŒˆ çç¨€åº¦ç³»ç»Ÿ (å½“å‰æ­£åœ¨æŠ½çš„é‚£å¼ ) ===
  @State rarityColor: string = 'rgba(0,0,0,0.15)';
  @State rarityLevel: number = 1;
  @State rarityLabel: string = 'N'; 

  // === ğŸ¬ åŠ¨ç”»çŠ¶æ€ ===
  @State angle: number = 0;
  @State floatOffsetY: number = 0;
  @State floatRotateZ: number = 0;
  @State clickScale: number = 1;
  @State mysteryScale: number = 1;

  // å…‰å½±ç‰¹æ•ˆ
  @State shadowOpacity: number = 0.15;
  @State shadowRadius: number = 10;
  @State shadowOffsetY: number = 5;
  @State shadowColor: string = 'rgba(0,0,0,0.2)';
  @State guideOpacity: number = 1;

  // æ´—ç‰ŒåŠ¨ç”»
  @State shuffleOffsetX: number = 0;
  @State shuffleRotate: number = 0;
  @State shuffleScale: number = 1;
  @State mainScale: number = 1;
  @State mainOffsetY: number = 0;
  @State mainOffsetX: number = 0; // æ–°å¢ï¼šXè½´ä½ç§»
  @State mainRotateZ: number = 0;

  // è£…é¥°æ€§ç‰Œå †
  @State deckOffset1: number = 0;
  @State deckOffset2: number = 0;
  @State deckOpacity: number = 0;
  @State deckScale: number = 0.9;
  @State deckAngle1: number = -5;
  @State deckAngle2: number = 5;

  // ğŸ‘» å¹»å½±ç‰Œå †
  @State phantomOffset1: number = 0;
  @State phantomOffset2: number = 0;
  @State phantomAngle1: number = 0;
  @State phantomAngle2: number = 0;
  @State phantomOpacity: number = 0;

  // ğŸ”’ äº¤äº’é”
  @State isAnimating: boolean = false;

  // === ğŸŒˆ ç‰¹æ•ˆå˜é‡ ===
  @State glowScale: number = 1;
  @State glowOpacity: number = 0;
  @State starScale: number = 0;
  @State flashOpacity: number = 0; 
  @State flashColor: string = '#FFFFFF'; 
  @State godRayRotate: number = 0; 
  @State godRayOpacity: number = 0; 

  // === ğŸ–¼ï¸ è¾¹æ¡†åŠ¨ç”»çŠ¶æ€ ===
  @State borderProgress: number = 0; 
  @State borderOpacity: number = 0;

  // === ğŸ›ï¸ å¼¹çª—çŠ¶æ€æ§åˆ¶ ===
  @State isGallerySheetOpen: boolean = false;
  @State isEnergySheetOpen: boolean = false;
  @State isDeckSheetOpen: boolean = false;

  // === ğŸ¨ ç‰Œç»„ä¸»é¢˜ ===
  @StorageLink('CurrentDeckFolder') currentDeckFolder: string = 'impasto%20style/';

  // === æ•°æ® ===
  @State galleryList: CardRecord[] = [];
  @State collectionProgress: number = 0;
  @State stickers: string[] = [];
  @State todayDate: string = "";
  @State todayWeek: string = "";

  // === P0ï¼šæƒ…ç»ªä¸ä»»åŠ¡ ===
  @State moodIndex: number = -1;
  @State moodNote: string = '';
  @State goldQuote: string = '';
  @State dailyTask: string = '';

  // === P2/P4ï¼šå‘¼å¸ä¸ç§å¯† ===
  @State isBreathingSheetOpen: boolean = false;
  @State breathingPhase: string = 'å‡†å¤‡';
  @State breathingRemaining: number = 60;
  @State privacyMode: boolean = false;

  // === âš¡ èƒ½é‡æ˜¾ç¤ºä¸å……å€¼ ===
  @State currentEnergy: number = 0;

  // === ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯ ===
  @State currentUserInfo: UserInfo | null = null;

  private manager = FortuneManager.getInstance();
  private energyManager = EnergyManager.getInstance();
  private userManager = UserManager.getInstance();
  private context = getContext(this) as common.UIAbilityContext;

  private asyncAnimateTo(duration: number, curve: Curve | string | ICurve, updateFn: () => void): Promise<void> {
    return new Promise((resolve) => {
      animateTo({ duration: duration, curve: curve, onFinish: resolve }, updateFn);
    });
  }

  getCardImageSource(url: string): ResourceStr {
    const finalUrl = resolveDeckImage(url, this.currentDeckFolder);
    if (finalUrl && finalUrl.startsWith('http')) {
      return finalUrl;
    }
    return $rawfile(url);
  }

  async aboutToAppear() {
    await this.manager.init(this.context);
    await this.energyManager.init(this.context);
    this.refreshEnergy();

    this.checkState();
    this.initDate();
    this.startGuideAnimation();

    const mood = await this.manager.getTodayMood();
    this.moodIndex = mood.mood;
    this.moodNote = mood.note;

    const aff = await this.manager.getTodayAffirmations();
    this.goldQuote = aff.quote;
    this.dailyTask = aff.task;
    this.privacyMode = await this.manager.isPrivacyMode();

    this.refreshLoginStatus();
  }

  onPageShow() {
    this.refreshEnergy();
    void (async () => {
      const mood = await this.manager.getTodayMood();
      this.moodIndex = mood.mood;
    })();
    this.refreshLoginStatus();
  }

  refreshEnergy() {
    this.currentEnergy = this.energyManager.getEnergy();
  }

  refreshLoginStatus() {
    this.currentUserInfo = this.userManager.getCurrentUser();
  }

  initDate() {
    const now = new Date();
    this.todayDate = `${now.getFullYear()}.${(now.getMonth() + 1).toString().padStart(2, '0')}.${now.getDate().toString().padStart(2, '0')}`;
    const weeks = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    this.todayWeek = weeks[now.getDay()];
  }

  async checkState() {
    this.isVip = await this.manager.isVip();
    const savedData = await this.manager.checkTodayCard();
    
    if (savedData && savedData.cards && savedData.cards.length > 0) {
      this.drawnCards = savedData.cards;
      this.drawnRarityLevels = savedData.rarityLevels;
      this.drawnRarityColors = savedData.rarityColors;
      
      // å¦‚æœå·²ç»æŠ½å®Œ3å¼ ï¼Œæç¤ºçŠ¶æ€
      if (this.drawnCards.length >= 3) {
         this.isFlipped = true;
         this.showResultText = true;
      } else {
         // æ¢å¤äº†ä¸€éƒ¨åˆ†
         this.isFlipped = false;
      }

      // æ¢å¤ Form (åªæ˜¾ç¤ºç¬¬ä¸€å¼ )
      this.updateForm(this.drawnCards[0]);
    } else {
      this.resetUI();
    }

    void (async () => {
      const restored = await CloudService.autoRestore();
      if (restored) {
        const newSavedCard = await this.manager.checkTodayCard();
        if (newSavedCard && (!this.drawnCards || this.drawnCards.length === 0)) {
          this.checkState();
        }
        promptAction.showToast({ message: 'â˜ï¸ æ•°æ®å·²ä»äº‘ç«¯åŒæ­¥' });
      }
    })();
  }

  resetUI() {
    this.drawnCards = [];
    this.drawnRarityLevels = [];
    this.drawnRarityColors = [];
    this.currentCard = null;
    this.angle = 0;
    this.isFlipped = false;
    this.showResultText = false;
    this.rarityColor = 'rgba(0,0,0,0.15)';
    this.stopBreathingAnimation();
    this.mainReset();
    this.borderProgress = 0;
    this.borderOpacity = 0;
  }

  mainReset() {
    this.shuffleOffsetX = 0;
    this.shuffleRotate = 0;
    this.shuffleScale = 1;
    this.phantomOpacity = 0;
    this.phantomOffset1 = 0;
    this.phantomOffset2 = 0;
    this.phantomAngle1 = 0;
    this.phantomAngle2 = 0;
    this.isAnimating = false;
    this.godRayOpacity = 0;
    this.godRayRotate = 0;
    this.mainOffsetX = 0;
    this.mainOffsetY = 0;
  }

  @Builder ComplexBorderBuilder() {
    Stack() {
      Row()
        .width(`${Math.min(Math.max(this.borderProgress, 0), 1) * 92}%`)
        .height(3)
        .backgroundColor('#FFD700')
        .shadow({ radius: 2, color: '#AA8800', offsetY: 0 })
        .position({ x: '4%', y: 8 })

      Column()
        .height(`${Math.min(Math.max(this.borderProgress - 1, 0), 1) * 92}%`)
        .width(3)
        .backgroundColor('#FFD700')
        .shadow({ radius: 2, color: '#AA8800', offsetY: 0 })
        .position({ x: '94%', y: '4%' })

      Row()
        .width(`${Math.min(Math.max(this.borderProgress - 2, 0), 1) * 92}%`)
        .height(3)
        .backgroundColor('#FFD700')
        .shadow({ radius: 2, color: '#AA8800', offsetY: 0 })
        .position({ x: '4%', y: '94%' })

      Column()
        .height(`${Math.min(Math.max(this.borderProgress - 3, 0), 1) * 92}%`)
        .width(3)
        .backgroundColor('#FFD700')
        .shadow({ radius: 2, color: '#AA8800', offsetY: 0 })
        .position({ x: 8, y: '4%' })

      if (this.borderProgress > 0.1) {
        Text("âœ¦").fontSize(16).fontColor('#FFD700').position({ x: 2, y: 2 })
          .transition({ type: TransitionType.Insert, opacity: 0, scale: { x: 0, y: 0 } })
      }
      // ... å…¶ä»–è§’çœç•¥ï¼Œä¿ç•™æ ¸å¿ƒè§†è§‰ ...
      
      Stack() {
        Rect().width('100%').height('100%').fill('transparent')
          .stroke('#AAFFD700').strokeWidth(1)
      }
      .width('85%').height('90%')
      .opacity(this.borderProgress > 3.5 ? 1 : 0)
      .animation({ duration: 500 })
    }
    .width('100%')
    .height('100%')
    .hitTestBehavior(HitTestMode.None)
    .opacity(this.borderOpacity)
  }

  @Builder GodRayBuilder() {
    Stack() {
      ForEach([0, 45, 90, 135], (angle: number) => {
        Column()
          .width(30)
          .height(600)
          .linearGradient({
            direction: GradientDirection.Top,
            colors: [[this.rarityLevel === 6 ? '#FFD700' : '#FF4500', 0], ['rgba(255,255,255,0)', 0.5], [this.rarityLevel === 6 ? '#FFD700' : '#FF4500', 1]]
          })
          .opacity(0.3)
          .rotate({ angle: angle })
      })
      ForEach([22.5, 67.5, 112.5, 157.5], (angle: number) => {
        Column()
          .width(15)
          .height(500)
          .linearGradient({
            direction: GradientDirection.Top,
            colors: [['#FFFFFF', 0], ['rgba(255,255,255,0)', 0.5], ['#FFFFFF', 1]]
          })
          .opacity(0.4)
          .rotate({ angle: angle })
      })
    }
    .width(500)
    .height(500)
    .rotate({ angle: this.godRayRotate })
    .opacity(this.godRayOpacity)
    .hitTestBehavior(HitTestMode.None)
  }

  updateForm(card: TarotCard) {
    try {
      const formData = formBindingData.createFormBindingData({
        'cardImage': card.image,
        'cardName': card.name,
        'cardDesc': card.meaning,
        'goldQuote': this.goldQuote,
        'dailyTask': this.dailyTask,
        'moodNote': this.moodNote,
        'privacyMode': this.privacyMode
      });
      void (async () => {
        const ids = await this.manager.getFormIds();
        for (const id of ids) {
          try {
            await formProvider.updateForm(id, formData);
          } catch (e) {
          }
        }
      })();
    } catch (err) {
    }
  }

  handleManualReset() {
    this.resetUI();
    promptAction.showToast({ message: 'ğŸ”„ å·²é‡ç½®', duration: 1000 });
  }

  handleBuyVip() {
    animateTo({ duration: 300, curve: Curve.EaseOut }, () => {
      this.isEnergySheetOpen = true;
    });
  }

  async handleRecharge(amount: number) {
    await this.energyManager.recharge(amount);
    this.refreshEnergy();
    promptAction.showToast({ message: `âš¡ æˆåŠŸè¡¥å…… ${amount} ç‚¹å¿ƒåŠ›ï¼` });
    animateTo({ duration: 300 }, () => {
      this.isEnergySheetOpen = false;
    });
  }

  calculateRarity() {
    const rand = Math.random() * 100;
    let config = RARITY_CONFIG[0]; 
    if (rand < 1) config = RARITY_CONFIG.find(c => c.level === 6) || config;      
    else if (rand < 6) config = RARITY_CONFIG.find(c => c.level === 5) || config; 
    else if (rand < 20) config = RARITY_CONFIG.find(c => c.level === 4) || config;
    else if (rand < 50) config = RARITY_CONFIG.find(c => c.level === 3) || config;
    else config = RARITY_CONFIG.find(c => c.level === 1) || config;               
    this.rarityLevel = config.level;
    this.rarityColor = config.color;
    this.rarityLabel = config.label;
  }

  getFlipDurationByRarity(): number {
    const map = [800, 900, 1000, 1200, 1500, 1800, 2000];
    const idx = Math.min(Math.max(this.rarityLevel, 1), 7) - 1;
    return map[idx];
  }

  startGuideAnimation() { animateTo({ duration: 1500, curve: Curve.EaseInOut, iterations: -1, playMode: PlayMode.Alternate }, () => { this.guideOpacity = 0.3; }); }

  startMysteryAnimation() {
    animateTo({ duration: 2000, curve: Curve.EaseInOut, iterations: -1, playMode: PlayMode.Alternate }, () => {
      this.mysteryScale = 1.05;
      this.shadowRadius = 20;
      this.shadowColor = 'rgba(100,0,200,0.3)';
    });
  }
  stopMysteryAnimation() { animateTo({ duration: 300 }, () => { this.mysteryScale = 1; this.shadowRadius = 10; this.shadowColor = 'rgba(0,0,0,0.15)'; }); }

  startBreathingAnimation() {
    animateTo({ duration: 2500, curve: Curve.EaseInOut, iterations: -1, playMode: PlayMode.Alternate }, () => { this.floatOffsetY = -12; });
    animateTo({ duration: 3500, curve: Curve.Smooth, iterations: -1, playMode: PlayMode.Alternate }, () => { this.floatRotateZ = 1.5; });
  }
  stopBreathingAnimation() { animateTo({ duration: 0 }, () => { this.floatOffsetY = 0; this.floatRotateZ = 0; }); }

  handleClickFeedback() { animateTo({ duration: 100, curve: Curve.EaseOut }, () => { this.clickScale = 0.95; }); setTimeout(() => { animateTo({ duration: 400, curve: curves.springMotion(0.5, 0.6) }, () => { this.clickScale = 1; }); }, 100); }

  async handleDrawCard() {
    if (this.drawnCards.length >= 3) {
      promptAction.showToast({ message: 'ğŸ“… ä»Šæ—¥å·²æŠ½å–ä¸‰å¼ ç‰Œï¼Œè¯·è¿›è¡Œæ·±åº¦è§£è¯»', duration: 2000 });
      this.handleClickFeedback();
      return;
    }

    if (this.isAnimating) return;
    this.isAnimating = true;

    this.guideOpacity = 0;
    this.stopMysteryAnimation();
    
    this.mainOffsetX = 0;
    this.mainOffsetY = 0;
    this.angle = 0;
    this.isFlipped = false;
    this.currentCard = null; 

    await this.asyncAnimateTo(300, Curve.EaseOut, () => {
      this.mainScale = 0.9;
      this.shadowRadius = 5;
      this.shadowOffsetY = 2;
      this.deckOpacity = 1;
      this.phantomOpacity = 1;
      this.deckOffset1 = 0; this.deckOffset2 = 0;
      this.phantomOffset1 = 0; this.phantomOffset2 = 0;
    });

    for (let i = 0; i < 4; i++) {
      const dir = i % 2 === 0 ? 1 : -1;
      await this.asyncAnimateTo(150, Curve.Rhythm, () => {
        this.shuffleRotate = 2 * dir;
        this.deckOffset1 = -20 * dir;
        this.deckOffset2 = 20 * dir;
        this.phantomOffset1 = -40 * dir;
        this.phantomOffset2 = 40 * dir;
        this.deckAngle1 = -5 * dir;
        this.deckAngle2 = 5 * dir;
      });
    }

    const newCard = await this.manager.drawRandomCard();
    this.currentCard = newCard;
    this.calculateRarity();
    
    await this.asyncAnimateTo(500, curves.springMotion(0.6, 0.8), () => {
      this.shuffleRotate = 0;
      this.mainScale = 1.0;
      this.deckOffset1 = -60;   this.deckAngle1 = -10;
      this.deckOffset2 = 60;    this.deckAngle2 = 10;
      this.phantomOffset1 = -120; this.phantomAngle1 = -20;
      this.phantomOffset2 = 120;  this.phantomAngle2 = 20;
    });

    await new Promise<void>(r => setTimeout(r, 200));

    await this.asyncAnimateTo(500, curves.springMotion(0.7, 0.7), () => {
      this.mainScale = 1.1;
      this.mainOffsetY = -50; 
      this.shadowRadius = 30;
      this.shadowColor = 'rgba(0,0,0,0.3)';
      
      this.deckOpacity = 0;
      this.phantomOpacity = 0;
      this.deckOffset1 = -200; this.deckOffset2 = 200;
      this.phantomOffset1 = -300; this.phantomOffset2 = 300;
    });

    const flipDuration = this.getFlipDurationByRarity();
    
    animateTo({ duration: flipDuration, curve: Curve.EaseInOut }, () => {
      this.angle = 180;
    });

    setTimeout(() => {
        this.isFlipped = true;
    }, flipDuration / 2);

    await new Promise<void>(r => setTimeout(r, flipDuration + 200));

    const slotIndex = this.drawnCards.length;
    let targetX = 0;
    // æ ¹æ®å±å¹•å®½åº¦åŠ¨æ€è®¡ç®—ï¼Œè¿™é‡Œæš‚å®š 360vp å±å¹•å®½ï¼Œæ¯å¼ å¡ 80ï¼Œé—´è· 20
    // Slot 0: -100, Slot 1: 0, Slot 2: 100
    if (slotIndex === 0) targetX = -100;
    else if (slotIndex === 1) targetX = 0;
    else if (slotIndex === 2) targetX = 100;

    await this.asyncAnimateTo(500, curves.springMotion(0.6, 0.8), () => {
        this.mainOffsetX = targetX;
        this.mainOffsetY = -250; // å‘ä¸Šå½’ä½åˆ°æ§½ä½
        this.mainScale = 0.4; // ç¼©å°
    });

    this.drawnCards.push(newCard);
    this.drawnRarityLevels.push(this.rarityLevel);
    this.drawnRarityColors.push(this.rarityColor);
    
    await this.manager.saveTodayState(this.drawnCards, this.drawnRarityLevels, this.drawnRarityColors);
    CloudService.autoSave();
    
    this.isAnimating = false;
    this.currentCard = null; // åŠ¨ç”»ç»“æŸï¼Œå¡ç‰‡è¿›å…¥åˆ—è¡¨ï¼Œå½“å‰åŠ¨ç”»å¡ç‰‡æ¸…ç©º

    if (this.drawnCards.length === 3) {
       promptAction.showToast({ message: 'âœ¨ æŠ½å–å®Œæˆï¼Œè¯·ç‚¹å‡»æ·±åº¦è§£è¯»', duration: 3000 });
    }
  }

  async handleUserClick() {
    if (this.currentUserInfo) {
      promptAction.showDialog({
        title: 'è´¦å·ç®¡ç†',
        message: `å½“å‰ç™»å½•ï¼š${this.currentUserInfo.nickname}\næ˜¯å¦é€€å‡ºç™»å½•ï¼Ÿ`,
        buttons: [
          { text: 'é€€å‡ºç™»å½•', color: '#FF0000' },
          { text: 'å–æ¶ˆ', color: '#999999' }
        ]
      }, (err, data) => {
        if (data.index === 0) {
          this.userManager.logout();
          this.refreshLoginStatus();
          promptAction.showToast({ message: 'å·²é€€å‡ºç™»å½•' });
        }
      });
    } else {
      try {
        const user = await this.userManager.login(this.context);
        this.refreshLoginStatus();
        promptAction.showToast({ message: `æ¬¢è¿ï¼Œ${user.nickname}` });
      } catch (e) {
      }
    }
  }

  async handleCloudSync() {
    // ... (Keep existing logic if needed, but for brevity in rewrite I'll assume standard CloudService usage)
    // For safety, I'll restore the original logic here
    let currentUser = this.userManager.getCurrentUser();

    if (!this.userManager.isLoggedIn()) {
      try {
        promptAction.showToast({ message: 'æ­£åœ¨è¿æ¥åä¸ºè´¦å·...', duration: 1500 });
        currentUser = await this.userManager.login(this.context);
        this.refreshLoginStatus();
        promptAction.showToast({ message: `æ¬¢è¿å›æ¥ï¼Œ${currentUser.nickname}`, duration: 2000 });
      } catch (err) {
        promptAction.showToast({ message: 'éœ€è¦ç™»å½•æ‰èƒ½åŒæ­¥æ•°æ®å“¦', duration: 2000 });
        return;
      }
    }

    if (!currentUser) return;
    const realUserId = currentUser.userId;
    const realToken = currentUser.token;

    promptAction.showToast({ message: 'æ­£åœ¨è¿æ¥äº‘ç«¯...', duration: 1000 });
    const isOnline = await CloudService.checkConnection();
    const statusEmoji = isOnline ? 'ğŸŸ¢' : 'ğŸ”´';
    const statusText = isOnline ? 'æœåŠ¡å™¨åœ¨çº¿' : 'æœåŠ¡å™¨è¿æ¥å¤±è´¥';

    promptAction.showDialog({
      title: `â˜ï¸ äº‘ç«¯åŒæ­¥ (${statusEmoji} ${statusText})`,
      message: isOnline
        ? `å½“å‰è´¦å·: ${currentUser.nickname}\nè¯·é€‰æ‹©æ“ä½œï¼š\nâ€¢ ä¸Šä¼ ï¼šå¤‡ä»½æœ¬æœºæ•°æ®åˆ°äº‘ç«¯\nâ€¢ ä¸‹è½½ï¼šä»äº‘ç«¯æ¢å¤æ•°æ®åˆ°æœ¬æœº`
        : 'âš ï¸ æ— æ³•è¿æ¥åˆ°äº‘æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚',
      buttons: [
        { text: 'â¬†ï¸ ä¸Šä¼ å¤‡ä»½', color: isOnline ? '#007DFF' : '#CCCCCC' },
        { text: 'â¬‡ï¸ ä¸‹è½½æ¢å¤', color: isOnline ? '#007DFF' : '#CCCCCC' },
        { text: 'å–æ¶ˆ', color: '#999999' }
      ]
    }, async (err, data) => {
      if (err || data.index === 2 || !isOnline) return;
      if (data.index === 0) {
        promptAction.showToast({ message: 'æ­£åœ¨ä¸Šä¼ å¤‡ä»½...', duration: 2000 });
        const allData = await this.manager.exportAllData();
        const success = await CloudService.backupData(realUserId, realToken, allData);
        if (success) promptAction.showToast({ message: 'âœ… å¤‡ä»½æˆåŠŸï¼' });
        else promptAction.showToast({ message: 'âŒ å¤‡ä»½å¤±è´¥' });
      } else {
        promptAction.showToast({ message: 'æ­£åœ¨ä¸‹è½½æ¢å¤...', duration: 2000 });
        const jsonStr = await CloudService.restoreData(realUserId, realToken);
        if (jsonStr) {
          const ok = await this.manager.importData(jsonStr);
          if (ok) {
            promptAction.showToast({ message: 'âœ… æ¢å¤æˆåŠŸï¼Œå³å°†åˆ·æ–°...' });
            this.checkState();
            this.initDate();
          } else promptAction.showToast({ message: 'âš ï¸ æ•°æ®è§£æå¤±è´¥' });
        } else promptAction.showToast({ message: 'âŒ æœªæ‰¾åˆ°äº‘ç«¯å¤‡ä»½æˆ–ä¸‹è½½å¤±è´¥' });
      }
    });
  }

  async handleNavigateToAnalysis() {
    // è·³è½¬åˆ° DeepAnalysisResultPageï¼Œä¼ é€’ 3 å¼ ç‰Œ
    if (this.drawnCards.length < 3) return;
    
    // æ„é€  Time Flow æ•°æ®
    // è¿™é‡Œæˆ‘ä»¬å‡è®¾ drawnCards[0]=Past, [1]=Present, [2]=Future
    // ä½†æ˜¯ DeepAnalysisResultPage éœ€è¦é€šè¿‡ params ä¼ é€’ä»€ä¹ˆï¼Ÿ
    // æŸ¥çœ‹ DeepAnalysisResultPageï¼Œå®ƒä¼¼ä¹æ¥æ”¶ `cards` å‚æ•°
    
    router.pushUrl({
      url: 'pages/DeepAnalysisResultPage',
      params: {
        cards: this.drawnCards,
        isDailyAnalysis: true, // æ ‡è®°ä¸ºæ¯æ—¥åˆ†æ
        isFree: await this.manager.isDailyDeepAnalysisFree()
      }
    });
  }
  
  async loadGalleryData() {
    this.isGallerySheetOpen = true;
    this.isEnergySheetOpen = false;
    this.galleryList = await this.manager.getGallery();
    this.collectionProgress = Math.round((this.galleryList.length / TAROT_DECK.length) * 100);
  }

  isCollected(id: number): boolean {
    return this.galleryList.some(c => c.cardId === id);
  }

  // === ğŸƒ æ ¸å¿ƒæ„å»º ===
  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 1. æ²‰æµ¸å¼èƒŒæ™¯ (æ·±é‚ƒæ˜Ÿç©ºç´«)
      Column()
        .width('100%').height('100%')
        .backgroundColor('#0f0c29')
        .linearGradient({
            direction: GradientDirection.Bottom,
            colors: [['#0f0c29', 0.0], ['#302b63', 0.5], ['#24243e', 1.0]]
        })
        .blur(this.isGallerySheetOpen || this.isEnergySheetOpen ? 20 : 0)
        .animation({ duration: 400 })

      // 2. åœ£å…‰ç‰¹æ•ˆå±‚ (å±…ä¸­)
      Column() {
        this.GodRayBuilder()
      }
      .width('100%').height('100%')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .hitTestBehavior(HitTestMode.None)

      // 3. ä¸»è¦å†…å®¹åŒºåŸŸ
      Column() {
          // 3.1 é¡¶éƒ¨ç©ºç™½ & çŠ¶æ€æ å ä½
          Blank().height(40)

          // 3.2 é¡¶éƒ¨åŠŸèƒ½æ  (èƒ½é‡/VIP/ç”¨æˆ·)
          Row() {
            // å·¦ä¾§ï¼šèƒ½é‡ & VIP
            Row({ space: 8 }) {
              Text('âš¡').fontColor('#FFD700').fontSize(18)
              Text(`${this.currentEnergy}`).fontColor('#FFD700').fontSize(16).fontWeight(FontWeight.Bold)
              if (this.isVip) {
                Text('VIP').fontSize(10).fontColor(Color.White).backgroundColor('#FFD700').padding({ left:6, right:6, top:2, bottom:2 }).borderRadius(8)
              } else {
                Text('Get VIP').fontSize(10).fontColor(Color.White).backgroundColor('rgba(255,255,255,0.2)').padding({ left:6, right:6, top:2, bottom:2 }).borderRadius(8)
                  .onClick(() => this.handleBuyVip())
              }
            }
            .backgroundColor('rgba(0,0,0,0.4)').padding(8).borderRadius(20)
            .onClick(() => this.handleBuyVip())

            Blank()

            // å³ä¾§ï¼šäº‘ç«¯ & ç”¨æˆ·
            Row({ space: 12 }) {
              Text('â˜ï¸').fontSize(22).onClick(() => this.handleCloudSync())
              if (this.currentUserInfo) {
                 Image(this.currentUserInfo.avatar).width(32).height(32).borderRadius(16).onClick(() => this.handleUserClick())
              } else {
                 Text('ğŸ‘¤').fontSize(22).onClick(() => this.handleUserClick())
              }
            }
          }
          .width('100%')
          .padding({ left: 16, right: 16 })
          .margin({ bottom: 20 })

          // 3.3 é¡¶éƒ¨æ§½ä½åŒºåŸŸ (æ˜¾ç¤ºå·²æŠ½å–çš„ç‰Œ)
          Row() {
            this.CardSlot(0, 'è¿‡å»')
            this.CardSlot(1, 'ç°åœ¨')
            this.CardSlot(2, 'æœªæ¥')
          }
          .width('100%')
          .justifyContent(FlexAlign.SpaceEvenly)
          .margin({ bottom: 40 })

          // 3.4 ä¸­å¤®æŠ½ç‰ŒåŒº (ç‰Œå † & åŠ¨ç”») - å æ®å‰©ä½™ç©ºé—´ç›´åˆ°åº•éƒ¨
          Stack() {
            // åº•éƒ¨å¹»å½± (ä»…å½“è¿˜æœ‰ç‰Œæ²¡æŠ½å®Œæ—¶æ˜¾ç¤º)
            if (this.drawnCards.length < 3) {
                Image(this.getCardImageSource(CARD_BACK_URL))
                  .width(200).aspectRatio(2/3).borderRadius(12)
                  .rotate({ angle: this.phantomAngle1 })
                  .offset({ x: this.phantomOffset1, y: 10 })
                  .opacity(this.phantomOpacity)
                  .animation({ duration: 500 })
                
                Image(this.getCardImageSource(CARD_BACK_URL))
                  .width(200).aspectRatio(2/3).borderRadius(12)
                  .rotate({ angle: this.phantomAngle2 })
                  .offset({ x: this.phantomOffset2, y: 10 })
                  .opacity(this.phantomOpacity)
                  .animation({ duration: 500 })

                // è£…é¥°æ€§ç‰Œå †
                Image(this.getCardImageSource(CARD_BACK_URL))
                  .width(200).aspectRatio(2/3).borderRadius(12)
                  .rotate({ angle: this.deckAngle1 })
                  .offset({ x: this.deckOffset1, y: 5 })
                  .opacity(this.deckOpacity)
                
                Image(this.getCardImageSource(CARD_BACK_URL))
                  .width(200).aspectRatio(2/3).borderRadius(12)
                  .rotate({ angle: this.deckAngle2 })
                  .offset({ x: this.deckOffset2, y: 5 })
                  .opacity(this.deckOpacity)
                
                // ä¸»ç‰Œå † (ç‚¹å‡»è§¦å‘)
                Image(this.getCardImageSource(CARD_BACK_URL))
                  .width(200).aspectRatio(2/3).borderRadius(12)
                  .shadow({ radius: this.shadowRadius, color: this.shadowColor, offsetY: this.shadowOffsetY })
                  .scale({ x: this.clickScale * this.mysteryScale, y: this.clickScale * this.mysteryScale })
                  .onClick(() => this.handleDrawCard())
                  .opacity(this.drawnCards.length < 3 ? 1 : 0) // æŠ½å®Œéšè—
                  .id('mainDeck')
            } else {
                // æŠ½å®Œåæ˜¾ç¤ºæ·±åº¦è§£è¯»æŒ‰é’®
                Column() {
                    Button('âœ¨ å¼€å¯æ·±åº¦è§£è¯»')
                      .backgroundColor('#FF69B4')
                      .fontColor(Color.White)
                      .fontSize(18)
                      .fontWeight(FontWeight.Bold)
                      .width(200)
                      .height(60)
                      .borderRadius(30)
                      .shadow({ radius: 10, color: 'rgba(255,105,180,0.5)', offsetY: 5 })
                      .onClick(() => this.handleNavigateToAnalysis())
                      .scale({ x: this.mysteryScale, y: this.mysteryScale }) // å¤ç”¨å‘¼å¸åŠ¨ç”»
                }
                .transition({ type: TransitionType.Insert, opacity: 0, scale: { x: 0.5, y: 0.5 } })
            }

            // === ğŸŒŸ æ­£åœ¨åŠ¨ç”»ä¸­çš„å¡ç‰Œ (ç‹¬ç«‹äºæ§½ä½å’Œç‰Œå †) ===
            if (this.currentCard) {
                Stack() {
                    // èƒŒé¢
                    Image(this.getCardImageSource(CARD_BACK_URL))
                      .width(200).aspectRatio(2/3).borderRadius(12)
                      .rotate({ y: 1, angle: this.angle }) // 0åº¦
                      .visibility(this.angle >= 90 ? Visibility.Hidden : Visibility.Visible)
                      .shadow({ radius: this.shadowRadius, color: this.shadowColor, offsetY: this.shadowOffsetY })

                    // æ­£é¢
                    Image(this.getCardImageSource(this.currentCard.image))
                      .width(200).aspectRatio(2/3).borderRadius(12)
                      .rotate({ y: 1, angle: this.angle - 180 }) // åˆå§‹ -180åº¦
                      .visibility(this.angle >= 90 ? Visibility.Visible : Visibility.Hidden)
                      .shadow({ radius: this.shadowRadius, color: this.shadowColor, offsetY: this.shadowOffsetY })
                      // ç¨€æœ‰åº¦è¾¹æ¡†
                      .overlay(this.ComplexBorderBuilder())
                }
                .scale({ x: this.mainScale, y: this.mainScale })
                .offset({ x: this.mainOffsetX, y: this.mainOffsetY })
                .rotate({ z: 1, angle: this.mainRotateZ })
                .zIndex(100) // ä¿è¯åœ¨æœ€ä¸Šå±‚
            }
          }
          .width('100%')
          .layoutWeight(1) // å æ®å‰©ä½™é«˜åº¦
          .alignContent(Alignment.Center)
          .margin({ bottom: 100 }) // é¿å¼€åº•éƒ¨å¯¼èˆªæ 
      }
      .width('100%')
      .height('100%')

      // 4. åº•éƒ¨å¯¼èˆªæ  (å›ºå®šåœ¨æœ€ä¸‹æ–¹)
      Column() {
         BottomNavBar({ current: 'index' })
      }
      .width('100%')
      .position({ x: 0, y: '100%' })
      .markAnchor({ x: 0, y: '100%' })
      .padding({ bottom: 16 })

      // 5. å„ç§å¼¹çª— Sheet
      // å›¾é‰´
      if (this.isGallerySheetOpen) {
        Column() {
          Row() {
             Text(`å·²æ”¶é›† ${this.galleryList.length}/${TAROT_DECK.length}`).fontColor(Color.White).fontSize(16)
             Blank()
             Text('âœ•').fontColor(Color.White).fontSize(20).onClick(() => this.isGallerySheetOpen = false)
          }.width('100%').padding(16)
          
          Grid() {
            ForEach(TAROT_DECK, (card: TarotCard) => {
              GridItem() {
                Column() {
                   if (this.isCollected(card.id)) {
                     Image(this.getCardImageSource(card.image)).width('100%').aspectRatio(2/3).borderRadius(8)
                   } else {
                     Image(this.getCardImageSource(CARD_BACK_URL)).width('100%').aspectRatio(2/3).borderRadius(8).opacity(0.5)
                   }
                }
              }
            })
          }
          .columnsTemplate('1fr 1fr 1fr 1fr')
          .rowsGap(10).columnsGap(10)
          .padding(16)
          .layoutWeight(1)
        }
        .width('100%').height('80%')
        .backgroundColor('#1a1a2e')
        .position({ y: '20%' })
        .transition({ translate: { y: 1000 } })
        .zIndex(200) // ç¡®ä¿åœ¨æœ€ä¸Šå±‚
      }

      // èƒ½é‡å……å€¼
      if (this.isEnergySheetOpen) {
        Column() {
          Text('âœ¨ è¡¥å……å¿ƒåŠ› âœ¨').fontSize(20).fontColor(Color.White).margin({ top: 20, bottom: 20 })
          Button('çœ‹è§†é¢‘è¡¥å…… (+10)').width('80%').height(50).onClick(() => this.handleRecharge(10)).margin({ bottom: 10 })
          Button('æ¯æ—¥ç­¾åˆ° (+5)').width('80%').height(50).onClick(() => this.handleRecharge(5))
          Text('âœ•').fontColor(Color.White).fontSize(24).position({ x: '90%', y: 20 }).onClick(() => this.isEnergySheetOpen = false)
        }
        .width('100%').height('40%')
        .backgroundColor('#1a1a2e')
        .position({ y: '60%' })
        .transition({ translate: { y: 1000 } })
        .zIndex(200)
      }

    }
    .width('100%')
    .height('100%')
  }

  @Builder CardSlot(index: number, label: string) {
    Column() {
      Text(label)
        .fontColor('rgba(255,255,255,0.6)')
        .fontSize(12)
        .margin({ bottom: 8 })
      
      if (this.drawnCards.length > index) {
        // å·²æŠ½å–
        Image(this.getCardImageSource(this.drawnCards[index].image))
          .width(80).aspectRatio(2/3).borderRadius(6)
          .shadow({ radius: 5, color: 'rgba(0,0,0,0.3)' })
          // ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…?
          .onClick(() => {
             // å¯ä»¥å¼¹çª—æ˜¾ç¤ºå¤§å›¾
          })
      } else {
        // ç©ºæ§½ä½
        Rect()
          .width(80).aspectRatio(2/3).radius(6)
          .fill('rgba(255,255,255,0.1)')
          .stroke('rgba(255,255,255,0.2)')
          .strokeWidth(1)
          .strokeDashArray([5, 5])
      }
    }
  }
}