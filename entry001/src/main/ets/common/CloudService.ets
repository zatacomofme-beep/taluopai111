import http from '@ohos.net.http';
import { promptAction } from '@kit.ArkUI';
import { UserManager } from './UserManager';
import { FortuneManager } from './FortuneManager';

export class CloudService {
  // æ›¿æ¢ä¸ºä½ çš„çœŸå® IP
  private static readonly BASE_URL = 'http://1.94.149.144:3000/api';
  private static readonly SERVER_ROOT = 'http://1.94.149.144:3000';

  static async checkConnection(): Promise<boolean> {
    const httpRequest = http.createHttp();
    try {
      const response = await httpRequest.request(`${CloudService.SERVER_ROOT}/`, {
        method: http.RequestMethod.GET,
        readTimeout: 3000,
        connectTimeout: 3000
      });
      return response.responseCode === 200;
    } catch (err) {
      return false;
    } finally {
      httpRequest.destroy();
    }
  }

  static async backupData(userId: string, token: string, allData: string): Promise<boolean> {
    const httpRequest = http.createHttp();
    try {
      const response = await httpRequest.request(`${CloudService.BASE_URL}/sync/upload`, {
        method: http.RequestMethod.POST,
        header: { 'Content-Type': 'application/json' },
        extraData: { userId: userId, token: token, data: JSON.parse(allData) },
        expectDataType: http.HttpDataType.OBJECT,
      });
      if (response.responseCode === 200) {
        const res = response.result as Record<string, Object>;
        return res['code'] === 200;
      }
      return false;
    } catch (err) {
      return false;
    } finally {
      httpRequest.destroy();
    }
  }

  static async restoreData(userId: string, token: string): Promise<string | null> {
    const httpRequest = http.createHttp();
    try {
      const response = await httpRequest.request(`${CloudService.BASE_URL}/sync/download`, {
        method: http.RequestMethod.POST,
        header: { 'Content-Type': 'application/json' },
        extraData: { userId: userId, token: token },
        expectDataType: http.HttpDataType.OBJECT,
      });
      if (response.responseCode === 200) {
        const res = response.result as Record<string, Object>;
        if (res['code'] === 200 && res['data']) {
          return JSON.stringify(res['data']);
        }
      }
      return null;
    } catch (err) {
      return null;
    } finally {
      httpRequest.destroy();
    }
  }

  // ğŸŸ¢ æ–°å¢ï¼šè‡ªåŠ¨äº‘å¤‡ä»½ (é™é»˜æ‰§è¡Œï¼Œåªåœ¨å¤±è´¥æ—¶æ‰“å°æ—¥å¿—ï¼Œä¸æ‰“æ‰°ç”¨æˆ·)
  static async autoSave() {
    const userMgr = UserManager.getInstance();
    const fortuneMgr = FortuneManager.getInstance();

    // 1. æ£€æŸ¥ç™»å½•çŠ¶æ€
    const user = userMgr.getCurrentUser();
    if (!userMgr.isLoggedIn() || !user) {
      console.info('CloudService: æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨å¤‡ä»½');
      return;
    }

    // 2. å‡†å¤‡æ•°æ®
    const allData = await fortuneMgr.exportAllData();

    // 3. æ‰§è¡Œä¸Šä¼  (ä¸é˜»å¡ä¸»çº¿ç¨‹)
    this.backupData(user.userId, user.token, allData).then((success) => {
      if (success) {
        console.info('â˜ï¸ CloudService: è‡ªåŠ¨å¤‡ä»½æˆåŠŸ');
      } else {
        console.warn('â˜ï¸ CloudService: è‡ªåŠ¨å¤‡ä»½å¤±è´¥');
      }
    });
  }

  // ğŸŸ¢ æ–°å¢ï¼šè‡ªåŠ¨äº‘æ¢å¤ (é€šå¸¸åœ¨ App å¯åŠ¨æ—¶è°ƒç”¨)
  static async autoRestore(): Promise<boolean> {
    const userMgr = UserManager.getInstance();
    const fortuneMgr = FortuneManager.getInstance();

    const user = userMgr.getCurrentUser();
    if (!userMgr.isLoggedIn() || !user) return false;

    const jsonStr = await this.restoreData(user.userId, user.token);
    if (jsonStr) {
      await fortuneMgr.importData(jsonStr);
      console.info('â˜ï¸ CloudService: è‡ªåŠ¨æ¢å¤æˆåŠŸ');
      return true;
    }
    return false;
  }
}