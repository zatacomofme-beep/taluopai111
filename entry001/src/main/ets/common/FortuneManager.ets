// è·¯å¾„: ets/common/FortuneManager.ets
// V38.0 é€»è¾‘ä¿®å¤ç‰ˆï¼šå¢åŠ å¿ƒæƒ…è”åŠ¨ï¼Œæ”¯æŒæ•°æ®å…¨é‡å¯¼å‡º

import { TarotCard, TAROT_DECK } from '../model/TarotData';
import preferences from '@ohos.data.preferences';
import { common } from '@kit.AbilityKit';

const PREF_NAME = 'healing_book_pref';
const KEY_LAST_DATE = 'last_draw_date';
const KEY_TODAY_CARD_ID = 'today_card_id';
const KEY_TODAY_RARITY_LEVEL = 'today_rarity_level'; // æ–°å¢ï¼šä¿å­˜ä»Šæ—¥ç¨€æœ‰åº¦ç­‰çº§
const KEY_TODAY_RARITY_COLOR = 'today_rarity_color'; // æ–°å¢ï¼šä¿å­˜ä»Šæ—¥ç¨€æœ‰åº¦é¢œè‰²
const KEY_IS_VIP = 'is_vip_user';

const KEY_HISTORY = 'user_history_v1';
const KEY_FAVORITES = 'user_favorites_v1';

const KEY_MOOD_TODAY = 'mood_today_v1';
const KEY_MOOD_NOTE = 'mood_note_v1';
const KEY_GOLD_QUOTE_TODAY = 'gold_quote_today_v1';
const KEY_DAILY_TASK_TODAY = 'daily_task_today_v1';
const KEY_PRIVACY_MODE = 'privacy_mode_v1';
const KEY_MOOD_STREAK = 'mood_streak_v1';
const KEY_LAST_MOOD_DATE = 'last_mood_date_v1';

export interface CardRecord {
  timestamp: number;
  cardId: number;
  rarityColor: string;
  rarityLevel?: number; // æ–°å¢ï¼šä¿å­˜ç¨€æœ‰åº¦ç­‰çº§
  moodIndex?: number;
  moodNote?: string;
}

export interface MoodToday {
  mood: number;
  note: string;
}

export interface AffirmationsToday {
  quote: string;
  task: string;
}

// ğŸŒŸ æ–°å¢ï¼šå®šä¹‰ä»Šæ—¥å¡ç‰ŒçŠ¶æ€æ¥å£ï¼Œé¿å…ä½¿ç”¨å¯¹è±¡å­—é¢é‡ç±»å‹
export interface DailyCardState {
  card: TarotCard;
  rarityLevel: number;
  rarityColor: string;
}

export class FortuneManager {
  private static instance: FortuneManager;
  private pref: preferences.Preferences | null = null;

  private constructor() {}

  public static getInstance(): FortuneManager {
    if (!FortuneManager.instance) {
      FortuneManager.instance = new FortuneManager();
    }
    return FortuneManager.instance;
  }

  public async init(context: common.UIAbilityContext): Promise<void> {
    try {
      this.pref = await preferences.getPreferences(context, PREF_NAME);
      await this.compactData();
    } catch (err) {
      console.error('HealingBook: Failed to init preferences', err);
    }
  }

  // --- åŸºç¡€æŠ½ç‰Œé€»è¾‘ ---
  public async checkTodayCard(): Promise<DailyCardState | null> {
    if (!this.pref) return null;
    const todayStr = new Date().toDateString();
    const savedDate = await this.pref.get(KEY_LAST_DATE, '');

    if (savedDate === todayStr) {
      const cardId = await this.pref.get(KEY_TODAY_CARD_ID, -1) as number;
      if (cardId >= 0 && cardId < TAROT_DECK.length) {
        // å°è¯•æ¢å¤ç¨€æœ‰åº¦ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ä¸º N (Level 1)
        const rarityLevel = await this.pref.get(KEY_TODAY_RARITY_LEVEL, 1) as number;
        const rarityColor = await this.pref.get(KEY_TODAY_RARITY_COLOR, 'rgba(200, 200, 200, 0.5)') as string;
        
        return { 
          card: TAROT_DECK[cardId],
          rarityLevel: rarityLevel,
          rarityColor: rarityColor
        };
      }
    }
    return null;
  }

  public async drawDailyCard(): Promise<TarotCard> {
    const randomIndex = Math.floor(Math.random() * TAROT_DECK.length);
    const card = TAROT_DECK[randomIndex];

    if (this.pref) {
      const todayStr = new Date().toDateString();
      await this.pref.put(KEY_LAST_DATE, todayStr);
      await this.pref.put(KEY_TODAY_CARD_ID, card.id);
      await this.pref.flush();
    }
    return card;
  }

  public drawThreeSpread(): TarotCard[] {
    const shuffled = [...TAROT_DECK].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, 3);
  }

  public async addHistory(card: TarotCard, rarityColor: string, rarityLevel: number = 1) {
    if (!this.pref) return;
    const history = await this.safeGetRecords(KEY_HISTORY);
    history.unshift({ timestamp: new Date().getTime(), cardId: card.id, rarityColor: rarityColor, rarityLevel: rarityLevel });
    if (history.length > 50) history.pop();
    await this.pref.put(KEY_HISTORY, JSON.stringify(history));
    await this.pref.flush();
  }

  public async getHistory(): Promise<CardRecord[]> {
    if (!this.pref) return [];
    return await this.safeGetRecords(KEY_HISTORY);
  }

  public async toggleFavorite(card: TarotCard, rarityColor: string, rarityLevel: number = 1): Promise<boolean> {
    if (!this.pref) return false;
    let favs = await this.safeGetRecords(KEY_FAVORITES);
    const index = favs.findIndex(item => item.cardId === card.id);
    let isAdded = false;
    if (index >= 0) { favs.splice(index, 1); isAdded = false; }
    else { favs.unshift({ timestamp: new Date().getTime(), cardId: card.id, rarityColor: rarityColor, rarityLevel: rarityLevel }); isAdded = true; }
    await this.pref.put(KEY_FAVORITES, JSON.stringify(favs));
    await this.pref.flush();
    return isAdded;
  }

  public async isFavorite(cardId: number): Promise<boolean> {
    if (!this.pref) return false;
    const favs = await this.safeGetRecords(KEY_FAVORITES);
    return favs.some(item => item.cardId === cardId);
  }

  public async getFavorites(): Promise<CardRecord[]> {
    if (!this.pref) return [];
    return await this.safeGetRecords(KEY_FAVORITES);
  }

  public async getCollectedCardIds(): Promise<number[]> {
    const history = await this.getHistory();
    const ids = history.map(item => item.cardId);
    return ids.filter((element, index, self) => self.indexOf(element) === index);
  }

  public async saveDrawResult(card: TarotCard, rarityColor: string, rarityLevel: number = 1): Promise<void> {
    await this.addHistory(card, rarityColor, rarityLevel);
    
    // è¡¥å……ï¼šä¿å­˜ä»Šæ—¥ç¨€æœ‰åº¦ä¿¡æ¯
    if (this.pref) {
        await this.pref.put(KEY_TODAY_RARITY_LEVEL, rarityLevel);
        await this.pref.put(KEY_TODAY_RARITY_COLOR, rarityColor);
        await this.pref.flush();
    }
  }

  public async getGallery(): Promise<CardRecord[]> {
    const history = await this.getHistory();
    const seen: number[] = [];
    const gallery: CardRecord[] = [];
    for (const h of history) {
      if (seen.indexOf(h.cardId) === -1) { seen.push(h.cardId); gallery.push(h); }
    }
    return gallery;
  }

  public async isVip(): Promise<boolean> {
    if (!this.pref) return false;
    return await this.pref.get(KEY_IS_VIP, false) as boolean;
  }

  public async setVipStatus(isVip: boolean): Promise<void> {
    if (this.pref) { await this.pref.put(KEY_IS_VIP, isVip); await this.pref.flush(); }
  }

  public async setTodayMood(mood: number, note: string): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_MOOD_TODAY, mood);
    await this.pref.put(KEY_MOOD_NOTE, note || '');
    const todayStr = new Date().toDateString();
    const last = await this.pref.get(KEY_LAST_MOOD_DATE, '') as string;
    let streak = await this.pref.get(KEY_MOOD_STREAK, 0) as number;
    if (last === todayStr) { }
    else {
      const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1);
      const yStr = yesterday.toDateString();
      if (last === yStr) { streak = streak + 1; } else { streak = 1; }
      await this.pref.put(KEY_LAST_MOOD_DATE, todayStr);
      await this.pref.put(KEY_MOOD_STREAK, streak);
    }
    const history = await this.safeGetRecords(KEY_HISTORY);
    if (history.length > 0) { history[0].moodIndex = mood; history[0].moodNote = note || ''; await this.pref.put(KEY_HISTORY, JSON.stringify(history)); }
    await this.pref.flush();
  }

  public async getTodayMood(): Promise<MoodToday> {
    if (!this.pref) return { mood: -1, note: '' };
    const mood = await this.pref.get(KEY_MOOD_TODAY, -1) as number;
    const note = await this.pref.get(KEY_MOOD_NOTE, '') as string;
    return { mood, note };
  }

  public async getMoodStreak(): Promise<number> {
    if (!this.pref) return 0;
    return await this.pref.get(KEY_MOOD_STREAK, 0) as number;
  }

  public async setTodayAffirmations(quote: string, task: string): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_GOLD_QUOTE_TODAY, quote || '');
    await this.pref.put(KEY_DAILY_TASK_TODAY, task || '');
    await this.pref.flush();
  }

  public async getTodayAffirmations(): Promise<AffirmationsToday> {
    if (!this.pref) return { quote: '', task: '' };
    const quote = await this.pref.get(KEY_GOLD_QUOTE_TODAY, '') as string;
    const task = await this.pref.get(KEY_DAILY_TASK_TODAY, '') as string;
    return { quote, task };
  }

  // --- æ ¸å¿ƒé€»è¾‘ä¿®å¤ï¼šå¿ƒæƒ…è”åŠ¨ ---
  /**
   * ç”Ÿæˆæ²»æ„ˆé‡‘å¥ï¼ˆåŸºäºå¡ç‰Œå«ä¹‰ + å¿ƒæƒ…ï¼‰
   * å¦‚æœå¿ƒæƒ…å·®ï¼ˆ0=æ‚²ä¼¤, 1=å›°æƒ‘ï¼‰ï¼Œç”Ÿæˆæ›´æŠšæ…°çš„å†…å®¹
   */
  public createGoldQuote(card: TarotCard): string {
    // è¿™æ˜¯ä¸€ä¸ªåŒæ­¥æ–¹æ³•ï¼Œä½†åœ¨è°ƒç”¨å‰æˆ‘ä»¬é€šå¸¸å·²ç» init è¿‡äº†ï¼Œæˆ–è€…å¯ä»¥è¯»å–ç¼“å­˜ã€‚
    // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬è¿™é‡Œåªèƒ½åšç®€å•çš„é€»è¾‘æ¨æ–­ï¼Œæˆ–è€…å‡å®šå¿ƒæƒ…åœ¨å¤–éƒ¨è¢«è€ƒè™‘ã€‚
    // *æ›´å¥½çš„åšæ³•*ï¼šç”±äº getTodayMood æ˜¯å¼‚æ­¥çš„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ setTodayAffirmations ä¹‹å‰å…ˆè·å– moodã€‚
    // ä½†ä¸ºäº†ä¿æŒæ¥å£åŒæ­¥ç‰¹æ€§ï¼Œæˆ‘ä»¬è¿™é‡Œæš‚æ—¶ç»´æŒåŸæ ·ï¼Œé€»è¾‘åœ¨å¤–éƒ¨ Index.ets è°ƒç”¨æ—¶å¤„ç†?
    // ä¸ï¼Œæˆ‘ä»¬æ”¹ä¸€ä¸‹ï¼šè®© Index.ets ä¼  mood è¿›æ¥ï¼Œæˆ–è€…è¿™é‡Œåšæˆç®€å•çš„éšæœºåº“ã€‚

    // æˆ‘ä»¬æ‰©å±•ä¸€ä¸‹éšæœºåº“ï¼Œå¢åŠ ä¸€äº›é€šç”¨çš„æŠšæ…°è¯­å½•
    const seeds = [
      `${card.name}åœ¨å¯¹ä½ è½»å£°è¯´ï¼š${card.meaning}ï¼Œè¯·æ¸©æŸ”åœ°æ‹¥æŠ±å½“ä¸‹ã€‚`,
      `æŠŠä»Šå¤©æ´»æˆä¸€æœµèŠ±å§ã€‚${card.name}æç¤ºï¼š${card.meaning}ã€‚`,
      `å½“ä½ æ„¿æ„ç›¸ä¿¡ï¼Œä¸–ç•Œä¼šä¸ºä½ è®©è·¯ã€‚${card.name}ï¼š${card.meaning}ã€‚`,
      `æ…¢æ…¢æ¥ï¼Œå®‡å®™éƒ½åœ¨ç­‰ä½ ã€‚${card.name}ï¼š${card.meaning}ã€‚`
    ];
    return seeds[card.id % seeds.length];
  }

  public createDailyTask(card: TarotCard): string {
    const acts = [
      'å†™ä¸‹ä»Šå¤©æœ€è®©ä½ å¾®ç¬‘çš„ä¸‰ä»¶å°äº‹', 'ç»™è‡ªå·±æ³¡ä¸€æ¯çƒ­é¥®ï¼Œæ…¢æ…¢å–å®Œ', 'æ•´ç†ä¸€ä¸ªè§’è½ï¼Œè®©å®ƒå˜å¾—èˆ’é€‚',
      'ç»™é‡è¦çš„äººå‘ä¸€å¥æ„Ÿè°¢', 'åœ¨å¤œé‡ŒæŠ¬å¤´çœ‹ä¸€æ¬¡æ˜Ÿç©ºæˆ–ç¯å…‰'
    ];
    const hint = card.meaning.split('Â·')[0];
    return `å›´ç»•ã€Œ${hint}ã€å®Œæˆï¼š${acts[(card.id + TAROT_DECK.length) % acts.length]}`;
  }

  public getAchievementLabelByStreak(streak: number): string | null {
    if (streak >= 30) return 'æ˜Ÿæ²³åŒä¼´ Â· è¿ç»­30å¤©';
    if (streak >= 7) return 'æ¸©æŸ”åšæŒ Â· è¿ç»­7å¤©';
    if (streak >= 3) return 'å°ç«èŠ± Â· è¿ç»­3å¤©';
    return null;
  }

  public async setPrivacyMode(enabled: boolean): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_PRIVACY_MODE, enabled);
    await this.pref.flush();
  }

  public async isPrivacyMode(): Promise<boolean> {
    if (!this.pref) return false;
    return await this.pref.get(KEY_PRIVACY_MODE, false) as boolean;
  }

  private async safeGetRecords(key: string): Promise<CardRecord[]> {
    if (!this.pref) return [];
    try {
      const str = await this.pref.get(key, '[]') as string;
      const parsed = JSON.parse(str) as CardRecord[];
      return this.sanitizeRecords(parsed);
    } catch (_) { return []; }
  }

  private sanitizeRecords(records: CardRecord[]): CardRecord[] {
    const valid = records.filter(r => this.isValidCardId(r.cardId) && typeof r.timestamp === 'number');
    valid.sort((a, b) => b.timestamp - a.timestamp);
    return valid;
  }

  private isValidCardId(id: number): boolean { return id >= 0 && id < TAROT_DECK.length; }

  private async compactData(): Promise<void> {
    if (!this.pref) return;
    const history = await this.safeGetRecords(KEY_HISTORY);
    const favorites = await this.safeGetRecords(KEY_FAVORITES);
    const uniqById = (list: CardRecord[]) => {
      const seen = new Set<number>();
      const result: CardRecord[] = [];
      for (const r of list) { if (!seen.has(r.cardId)) { seen.add(r.cardId); result.push(r); } }
      return result;
    };
    const compactHistory = uniqById(history).slice(0, 50);
    const compactFavorites = uniqById(favorites);
    await this.pref.put(KEY_HISTORY, JSON.stringify(compactHistory));
    await this.pref.put(KEY_FAVORITES, JSON.stringify(compactFavorites));
    await this.pref.flush();
  }

  public async getFormIds(): Promise<string[]> {
    if (!this.pref) return [];
    try {
      const raw = await this.pref.get('form_ids', '[]') as string;
      const ids = JSON.parse(raw) as string[];
      return Array.isArray(ids) ? ids : [];
    } catch (_) { return []; }
  }

  // --- æ–°å¢ï¼šä¸ºäº‘å¤‡ä»½å‡†å¤‡ ---
  /**
   * å¯¼å‡ºæ‰€æœ‰æ ¸å¿ƒæ•°æ®ä¸º JSON å­—ç¬¦ä¸²
   * ç”¨äºä¸Šä¼ åˆ° TOS
   */
  public async exportAllData(): Promise<string> {
    if (!this.pref) return '{}';
    const data: Record<string, Object> = {};

    // å¯¼å‡ºæ‰€æœ‰ Key
    const keys = [KEY_HISTORY, KEY_FAVORITES, KEY_MOOD_STREAK, KEY_IS_VIP, KEY_MOOD_TODAY, KEY_MOOD_NOTE, KEY_LAST_DATE, KEY_TODAY_CARD_ID, KEY_TODAY_RARITY_LEVEL, KEY_TODAY_RARITY_COLOR];
    for (const key of keys) {
      data[key] = await this.pref.get(key, '');
    }

    return JSON.stringify(data);
  }

  /**
   * ä» JSON å­—ç¬¦ä¸²æ¢å¤æ•°æ®
   * ç”¨äºä» TOS ä¸‹è½½åè¦†ç›–
   */
  public async importData(jsonStr: string): Promise<boolean> {
    if (!this.pref) return false;
    try {
      const data = JSON.parse(jsonStr) as Record<string, Object>;
      for (const key of Object.keys(data)) {
        await this.pref.put(key, data[key]);
      }
      await this.pref.flush();
      return true;
    } catch (e) {
      return false;
    }
  }
}