// è·¯å¾„: ets/common/FortuneManager.ets
// V37.3 ä¿®å¤ç‰ˆï¼šä¿®å¤ Set å±•å¼€è¯­æ³•æŠ¥é”™ï¼Œè§£å†³ Index.ets æ— æ³•è¯†åˆ«æ–¹æ³•çš„é—®é¢˜

import { TarotCard, TAROT_DECK } from '../model/TarotData';
import preferences from '@ohos.data.preferences';
import { common } from '@kit.AbilityKit';

const PREF_NAME = 'healing_book_pref';
const KEY_LAST_DATE = 'last_draw_date';
const KEY_TODAY_CARD_ID = 'today_card_id';
const KEY_IS_VIP = 'is_vip_user';

const KEY_HISTORY = 'user_history_v1';
const KEY_FAVORITES = 'user_favorites_v1';

const KEY_MOOD_TODAY = 'mood_today_v1';
const KEY_MOOD_NOTE = 'mood_note_v1';
const KEY_GOLD_QUOTE_TODAY = 'gold_quote_today_v1';
const KEY_DAILY_TASK_TODAY = 'daily_task_today_v1';
const KEY_PRIVACY_MODE = 'privacy_mode_v1';
const KEY_MOOD_STREAK = 'mood_streak_v1';
const KEY_LAST_MOOD_DATE = 'last_mood_date_v1';

// å®šä¹‰è®°å½•ç»“æ„
export interface CardRecord {
  timestamp: number; // æ—¶é—´æˆ³
  cardId: number;    // å¡ç‰ŒID
  rarityColor: string; // è®°å½•å½“æ—¶çš„æ¬§æ°”é¢œè‰²
  moodIndex?: number; // å¯é€‰ï¼šè®°å½•å½“æ—¶å¿ƒæƒ…
  moodNote?: string;  // å¯é€‰ï¼šè®°å½•å¿ƒæƒ…å¤‡æ³¨
}

export interface MoodToday {
  mood: number;
  note: string;
}

export interface AffirmationsToday {
  quote: string;
  task: string;
}

export class FortuneManager {
  private static instance: FortuneManager;
  private pref: preferences.Preferences | null = null;

  private constructor() {}

  public static getInstance(): FortuneManager {
    if (!FortuneManager.instance) {
      FortuneManager.instance = new FortuneManager();
    }
    return FortuneManager.instance;
  }

  /**
   * åˆå§‹åŒ–åå¥½å­˜å‚¨ï¼Œå¹¶è¿›è¡Œæ•°æ®å‹ç¼©ä¸æ ¡éªŒ
   */
  public async init(context: common.UIAbilityContext): Promise<void> {
    try {
      this.pref = await preferences.getPreferences(context, PREF_NAME);
      await this.compactData();
    } catch (err) {
      console.error('HealingBook: Failed to init preferences', err);
    }
  }

  // --- åŸºç¡€æŠ½ç‰Œé€»è¾‘ ---
  public async checkTodayCard(): Promise<TarotCard | null> {
    if (!this.pref) return null;
    const todayStr = new Date().toDateString();
    const savedDate = await this.pref.get(KEY_LAST_DATE, '');

    if (savedDate === todayStr) {
      const cardId = await this.pref.get(KEY_TODAY_CARD_ID, -1) as number;
      if (cardId >= 0 && cardId < TAROT_DECK.length) {
        return TAROT_DECK[cardId];
      }
    }
    return null;
  }

  public async drawDailyCard(): Promise<TarotCard> {
    const randomIndex = Math.floor(Math.random() * TAROT_DECK.length);
    const card = TAROT_DECK[randomIndex];

    if (this.pref) {
      const todayStr = new Date().toDateString();
      await this.pref.put(KEY_LAST_DATE, todayStr);
      await this.pref.put(KEY_TODAY_CARD_ID, card.id);
      await this.pref.flush();
    }
    return card;
  }

  public drawThreeSpread(): TarotCard[] {
    const shuffled = [...TAROT_DECK].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, 3);
  }

  // --- ğŸ“œ å†å²è®°å½•ç®¡ç† ---

  /**
   * æ–°å¢å†å²è®°å½•ï¼ˆæœ€å¤šä¿ç•™50æ¡ï¼Œæœ€æ–°åœ¨å‰ï¼‰
   */
  public async addHistory(card: TarotCard, rarityColor: string) {
    if (!this.pref) return;
    const history = await this.safeGetRecords(KEY_HISTORY);

    // æ–°è®°å½•æ’åˆ°æœ€å‰é¢
    history.unshift({
      timestamp: new Date().getTime(),
      cardId: card.id,
      rarityColor: rarityColor
    });

    // åªä¿ç•™æœ€è¿‘ 50 æ¡
    if (history.length > 50) history.pop();

    await this.pref.put(KEY_HISTORY, JSON.stringify(history));
    await this.pref.flush();
  }

  /**
   * è·å–å†å²è®°å½•ï¼ˆåŒ…å«å®¹é”™ï¼‰
   */
  public async getHistory(): Promise<CardRecord[]> {
    if (!this.pref) return [];
    return await this.safeGetRecords(KEY_HISTORY);
  }

  // --- â¤ï¸ æ”¶è—å¤¹ç®¡ç† ---

  /**
   * åˆ‡æ¢æ”¶è—ï¼ˆå­˜åœ¨åˆ™ç§»é™¤ï¼Œä¸å­˜åœ¨åˆ™æ·»åŠ ï¼‰
   */
  public async toggleFavorite(card: TarotCard, rarityColor: string): Promise<boolean> {
    if (!this.pref) return false;
    let favs = await this.safeGetRecords(KEY_FAVORITES);

    const index = favs.findIndex(item => item.cardId === card.id);
    let isAdded = false;

    if (index >= 0) {
      // å·²å­˜åœ¨ï¼Œå–æ¶ˆæ”¶è—
      favs.splice(index, 1);
      isAdded = false;
    } else {
      // ä¸å­˜åœ¨ï¼Œæ·»åŠ æ”¶è—
      favs.unshift({
        timestamp: new Date().getTime(),
        cardId: card.id,
        rarityColor: rarityColor
      });
      isAdded = true;
    }

    await this.pref.put(KEY_FAVORITES, JSON.stringify(favs));
    await this.pref.flush();
    return isAdded;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦å·²æ”¶è—
   */
  public async isFavorite(cardId: number): Promise<boolean> {
    if (!this.pref) return false;
    const favs = await this.safeGetRecords(KEY_FAVORITES);
    return favs.some(item => item.cardId === cardId);
  }

  /**
   * è·å–æ”¶è—åˆ—è¡¨ï¼ˆåŒ…å«å®¹é”™ï¼‰
   */
  public async getFavorites(): Promise<CardRecord[]> {
    if (!this.pref) return [];
    return await this.safeGetRecords(KEY_FAVORITES);
  }

  /**
   * è·å–å·²æ”¶é›†å¡ç‰‡IDé›†åˆï¼ˆå»é‡ï¼‰
   */
  public async getCollectedCardIds(): Promise<number[]> {
    const history = await this.getHistory();
    const ids = history.map(item => item.cardId);
    const uniqueIds = ids.filter((element, index, self) => self.indexOf(element) === index);
    return uniqueIds;
  }

  /**
   * ä¿å­˜æŠ½ç‰Œç»“æœåˆ°å±•è§ˆå…ï¼ˆå†å²ï¼‰
   */
  public async saveDrawResult(card: TarotCard, rarityColor: string): Promise<void> {
    await this.addHistory(card, rarityColor);
  }

  /**
   * ç”Ÿæˆå±•è§ˆå…æ•°æ®ï¼šæŒ‰å†å²ä¸­æœ€è¿‘ä¸€æ¬¡å‡ºç°çš„å¡ç‰‡å»é‡
   */
  public async getGallery(): Promise<CardRecord[]> {
    const history = await this.getHistory();
    const seen: number[] = [];
    const gallery: CardRecord[] = [];
    for (const h of history) {
      if (seen.indexOf(h.cardId) === -1) {
        seen.push(h.cardId);
        gallery.push(h);
      }
    }
    return gallery;
  }

  // --- VIP ---
  /**
   * è·å–VIPçŠ¶æ€
   */
  public async isVip(): Promise<boolean> {
    if (!this.pref) return false;
    return await this.pref.get(KEY_IS_VIP, false) as boolean;
  }

  /**
   * è®¾ç½®VIPçŠ¶æ€
   */
  public async setVipStatus(isVip: boolean): Promise<void> {
    if (this.pref) {
      await this.pref.put(KEY_IS_VIP, isVip);
      await this.pref.flush();
    }
  }

  /**
   * ä¿å­˜ä»Šæ—¥å¿ƒæƒ…ï¼ˆ0-4ï¼‰ä¸å¤‡æ³¨
   */
  public async setTodayMood(mood: number, note: string): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_MOOD_TODAY, mood);
    await this.pref.put(KEY_MOOD_NOTE, note || '');
    const todayStr = new Date().toDateString();
    const last = await this.pref.get(KEY_LAST_MOOD_DATE, '') as string;
    let streak = await this.pref.get(KEY_MOOD_STREAK, 0) as number;
    if (last === todayStr) {
      // å·²è®°å½•ä»Šæ—¥ï¼Œä¿æŒ streak
    } else {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yStr = yesterday.toDateString();
      if (last === yStr) { streak = streak + 1; } else { streak = 1; }
      await this.pref.put(KEY_LAST_MOOD_DATE, todayStr);
      await this.pref.put(KEY_MOOD_STREAK, streak);
    }
    const history = await this.safeGetRecords(KEY_HISTORY);
    if (history.length > 0) {
      history[0].moodIndex = mood;
      history[0].moodNote = note || '';
      await this.pref.put(KEY_HISTORY, JSON.stringify(history));
    }
    await this.pref.flush();
  }

  /**
   * è¯»å–ä»Šæ—¥å¿ƒæƒ…ä¸å¤‡æ³¨
   */
  public async getTodayMood(): Promise<MoodToday> {
    if (!this.pref) return { mood: -1, note: '' };
    const mood = await this.pref.get(KEY_MOOD_TODAY, -1) as number;
    const note = await this.pref.get(KEY_MOOD_NOTE, '') as string;
    return { mood, note };
  }

  /**
   * è¯»å–å¿ƒæƒ…è¿ç»­ç­¾åˆ°å¤©æ•°ï¼ˆå‡½æ•°çº§æ³¨é‡Šï¼‰
   */
  public async getMoodStreak(): Promise<number> {
    if (!this.pref) return 0;
    return await this.pref.get(KEY_MOOD_STREAK, 0) as number;
  }

  /**
   * ä¿å­˜ä»Šæ—¥æ²»æ„ˆé‡‘å¥ä¸å°ä»»åŠ¡
   */
  public async setTodayAffirmations(quote: string, task: string): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_GOLD_QUOTE_TODAY, quote || '');
    await this.pref.put(KEY_DAILY_TASK_TODAY, task || '');
    await this.pref.flush();
  }

  /**
   * è¯»å–ä»Šæ—¥æ²»æ„ˆé‡‘å¥ä¸å°ä»»åŠ¡
   */
  public async getTodayAffirmations(): Promise<AffirmationsToday> {
    if (!this.pref) return { quote: '', task: '' };
    const quote = await this.pref.get(KEY_GOLD_QUOTE_TODAY, '') as string;
    const task = await this.pref.get(KEY_DAILY_TASK_TODAY, '') as string;
    return { quote, task };
  }

  /**
   * ç”Ÿæˆæ²»æ„ˆé‡‘å¥ï¼ˆåŸºäºå¡ç‰Œå«ä¹‰ï¼Œçº¯æœ¬åœ°ï¼‰
   */
  public createGoldQuote(card: TarotCard): string {
    const seeds = [
      `${card.name}åœ¨å¯¹ä½ è½»å£°è¯´ï¼š${card.meaning}ï¼Œè¯·æ¸©æŸ”åœ°æ‹¥æŠ±å½“ä¸‹ã€‚`,
      `æŠŠä»Šå¤©æ´»æˆä¸€æœµèŠ±å§ã€‚${card.name}æç¤ºï¼š${card.meaning}ã€‚`,
      `å½“ä½ æ„¿æ„ç›¸ä¿¡ï¼Œä¸–ç•Œä¼šä¸ºä½ è®©è·¯ã€‚${card.name}ï¼š${card.meaning}ã€‚`,
      `æ…¢æ…¢æ¥ï¼Œå®‡å®™éƒ½åœ¨ç­‰ä½ ã€‚${card.name}ï¼š${card.meaning}ã€‚`
    ];
    return seeds[card.id % seeds.length];
  }

  /**
   * ç”Ÿæˆä»Šæ—¥å°ä»»åŠ¡ï¼ˆä¸ä¾èµ–åç«¯ï¼‰
   */
  public createDailyTask(card: TarotCard): string {
    const acts = [
      'å†™ä¸‹ä»Šå¤©æœ€è®©ä½ å¾®ç¬‘çš„ä¸‰ä»¶å°äº‹',
      'ç»™è‡ªå·±æ³¡ä¸€æ¯çƒ­é¥®ï¼Œæ…¢æ…¢å–å®Œ',
      'æ•´ç†ä¸€ä¸ªè§’è½ï¼Œè®©å®ƒå˜å¾—èˆ’é€‚',
      'ç»™é‡è¦çš„äººå‘ä¸€å¥æ„Ÿè°¢',
      'åœ¨å¤œé‡ŒæŠ¬å¤´çœ‹ä¸€æ¬¡æ˜Ÿç©ºæˆ–ç¯å…‰'
    ];
    const hint = card.meaning.split('Â·')[0];
    return `å›´ç»•ã€Œ${hint}ã€å®Œæˆï¼š${acts[(card.id + TAROT_DECK.length) % acts.length]}`;
  }

  /**
   * è®¡ç®—æˆå°±å¾½ç« æ–‡æ¡ˆï¼ˆå‡½æ•°çº§æ³¨é‡Šï¼‰
   */
  public getAchievementLabelByStreak(streak: number): string | null {
    if (streak >= 30) return 'æ˜Ÿæ²³åŒä¼´ Â· è¿ç»­30å¤©';
    if (streak >= 7) return 'æ¸©æŸ”åšæŒ Â· è¿ç»­7å¤©';
    if (streak >= 3) return 'å°ç«èŠ± Â· è¿ç»­3å¤©';
    return null;
  }

  /**
   * è®¾ç½®ç§å¯†æ¨¡å¼å¼€å…³
   */
  public async setPrivacyMode(enabled: boolean): Promise<void> {
    if (!this.pref) return;
    await this.pref.put(KEY_PRIVACY_MODE, enabled);
    await this.pref.flush();
  }

  /**
   * è¯»å–ç§å¯†æ¨¡å¼çŠ¶æ€
   */
  public async isPrivacyMode(): Promise<boolean> {
    if (!this.pref) return false;
    return await this.pref.get(KEY_PRIVACY_MODE, false) as boolean;
  }

  /**
   * è¯»å–å¹¶è§£æè®°å½•ï¼ˆå¸¦å®¹é”™ä¸è¿‡æ»¤ï¼‰
   */
  private async safeGetRecords(key: string): Promise<CardRecord[]> {
    if (!this.pref) return [];
    try {
      const str = await this.pref.get(key, '[]') as string;
      const parsed = JSON.parse(str) as CardRecord[];
      return this.sanitizeRecords(parsed);
    } catch (_) {
      return [];
    }
  }

  /**
   * æ¸…ç†æ— æ•ˆæ•°æ®ã€æŒ‰æ—¶é—´é™åºå¹¶é™åˆ¶é•¿åº¦
   */
  private sanitizeRecords(records: CardRecord[]): CardRecord[] {
    const valid = records.filter(r => this.isValidCardId(r.cardId) && typeof r.timestamp === 'number');
    valid.sort((a, b) => b.timestamp - a.timestamp);
    return valid;
  }

  /**
   * æœ‰æ•ˆå¡IDåˆ¤æ–­
   */
  private isValidCardId(id: number): boolean { return id >= 0 && id < TAROT_DECK.length; }

  /**
   * å¯åŠ¨æ—¶å‹ç¼©æ•°æ®ï¼Œä¿è¯æ¨¡æ‹Ÿå™¨é‡å¯åæ•°æ®ä»ç„¶ç¨³å®š
   */
  private async compactData(): Promise<void> {
    if (!this.pref) return;
    const history = await this.safeGetRecords(KEY_HISTORY);
    const favorites = await this.safeGetRecords(KEY_FAVORITES);

    // å»é‡ï¼šä¿ç•™åŒå¡ç‰‡çš„æœ€æ–°è®°å½•
    const uniqById = (list: CardRecord[]) => {
      const seen = new Set<number>();
      const result: CardRecord[] = [];
      for (const r of list) {
        if (!seen.has(r.cardId)) { seen.add(r.cardId); result.push(r); }
      }
      return result;
    };

    const compactHistory = uniqById(history).slice(0, 50);
    const compactFavorites = uniqById(favorites);

    await this.pref.put(KEY_HISTORY, JSON.stringify(compactHistory));
    await this.pref.put(KEY_FAVORITES, JSON.stringify(compactFavorites));
    await this.pref.flush();
  }

  /**
   * è¯»å–å½“å‰å·²å®‰è£…çš„æ¡Œé¢å¡ç‰‡ formId åˆ—è¡¨ï¼ˆå‡½æ•°çº§æ³¨é‡Šï¼‰
   */
  public async getFormIds(): Promise<string[]> {
    if (!this.pref) return [];
    try {
      const raw = await this.pref.get('form_ids', '[]') as string;
      const ids = JSON.parse(raw) as string[];
      return Array.isArray(ids) ? ids : [];
    } catch (_) {
      return [];
    }
  }
}
